function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/* eslint-disable react/prop-types */
import classNames from 'classnames';
import React from 'react';
import { propTypes, defaultProps } from '../PropTypes';
import camelCase from './camelCase';
import styles from './Layout.module.css';

function Block(_ref, ref) {
  var Component = _ref.as,
      _d = _ref.direction,
      _r = _ref.reverse,
      _p = _ref.pad,
      _w = _ref.wrap,
      grow = _ref.grow,
      inline = _ref.inline,
      flex = _ref.flex,
      _a = _ref.align,
      alignSelf = _ref.alignSelf,
      _aC = _ref.alignContent,
      _j = _ref.justify,
      className = _ref.className,
      style = _ref.style,
      props = _objectWithoutPropertiesLoose(_ref, ["as", "direction", "reverse", "pad", "wrap", "grow", "inline", "flex", "align", "alignSelf", "alignContent", "justify", "className", "style"]);

  var combinedStyle = style || flex != null ? _extends({}, style, {
    flex: flex === true ? 1 : flex
  }) : style;
  return React.createElement(Component, _extends({}, props, {
    ref: ref,
    style: combinedStyle,
    className: classNames(className, grow && styles.grow, inline ? styles.blockInline : styles.block, alignSelf && styles[camelCase(alignSelf)])
  }));
}

var DecoratedBlock = React.forwardRef(Block);
DecoratedBlock.propTypes = propTypes;
DecoratedBlock.defaultProps = defaultProps;
export default DecoratedBlock;